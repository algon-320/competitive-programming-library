/*
<NAME> Lazy Propagate Segment Tree (動的構築)
<TRIGGER> LazySeg
<TAG> data-structure
<*NOTE>
更新$O(log N)$、クエリO(log N)。

- `update_func`: 更新時に使われる関数
- `merge_func`: クエリの計算に使われる関数
- `propagate_func`: lazyの伝搬に使われる関数

<*CODE> */
template <class T>
struct LazySegmentTree {
    using func = function<T(T, T)>;
    int size;
    unordered_map<int, T> data;
    unordered_map<int, T> lazy;
    func updater, merger, propagater;
    T ident_prop, ident_query;
     T &access_data(int idx) {
        if (data.find(idx) != data.end()) return data[idx];
        data[idx] = ident_query;
        return data[idx];
    }
    T &access_lazy(int idx) {
        if (lazy.find(idx) != lazy.end()) return lazy[idx];
        lazy[idx] = ident_prop;
        return lazy[idx];
    }

    LazySegmentTree(int n, func update_func, func merge_func,
      func propagate_func, T identity_propagate, T identity_query)
      : updater(update_func), merger(merge_func), propagater(propagate_func),
      ident_prop(identity_propagate), ident_query(identity_query) {
        size = 1;
        while (size < n) size <<= 1;
    }
    void lazy_propagate(int p) {
        access(data, p) = updater(access(data, p), access(lazy, p));
        if (p < size-1) {
            access(lazy, p * 2 + 1) = propagater(access(lazy, p * 2 + 1), access(lazy, p));
            access(lazy, p * 2 + 2) = propagater(access(lazy, p * 2 + 2), access(lazy, p));
        }
        access(lazy, p) = ident_prop;
    }
    void update(int wishL, int wishR, int x, int watchL = 0, int watchR = -1, int k = 0) {
        if (watchR == -1) watchR = size;
        if (wishR <= watchL || watchR <= wishL) {
            lazy_propagate(k);
            return;
        }
        if (wishL <= watchL && watchR <= wishR) {
            access(lazy, k) = propagater(access(lazy, k), x);
            lazy_propagate(k);
            return;
        }

        int mid = (watchL + watchR) / 2;
        lazy_propagate(k);
        update(wishL, wishR, x, watchL, mid, k * 2 + 1);
        update(wishL, wishR, x, mid, watchR, k * 2 + 2);
        access(data, k) = merger(access(data,  k * 2 + 1), access(data,  k * 2 + 2));
    }
    T query(int wishL, int wishR, int watchL = 0, int watchR = -1, int k = 0) {
        if (watchR == -1) watchR = size;
        if (watchR <= wishL || wishR <= watchL) return ident_query;
        if (wishL <= watchL && watchR <= wishR) {
            lazy_propagate(k);
            return access(data, k);
        }
        lazy_propagate(k);
        T ld = query(wishL, wishR, watchL, (watchL + watchR) / 2, k * 2 + 1);
        T rd = query(wishL, wishR, (watchL + watchR) / 2, watchR, k * 2 + 2);
        return merger(ld, rd);
    }
};