/*
<NAME> Lazy Propagate Segment Tree
<TRIGGER> LazySeg
<TAG> data-structure
<*NOTE>
更新$O(log N)$、クエリO(log N)。

- `update_func`: 更新時に使われる関数
- `merge_func`: クエリの計算に使われる関数
- `propagate_func`: lazyの伝搬に使われる関数

<*CODE> */
template <class T>
struct LazySegmentTree {
    using func = function<T(T, T)>;
    int size;
    vector<T> data;
    vector<T> lazy;
    vector<T> width;
    function<T(T, T, int)> updater;
    func merger, propagater;
    T ident_prop, ident_query;

    LazySegmentTree(int n, function<T(T, T, int)> update_func, func merge_func,
      func propagate_func, T identity_propagate, T identity_query)
      : updater(update_func), merger(merge_func), propagater(propagate_func),
      ident_prop(identity_propagate), ident_query(identity_query) {
        size = 1;
        while (size < n) size <<= 1;
        data.resize(size * 2, ident_query);
        lazy.resize(size * 2, ident_prop);
        width.resize(size * 2, 1);
        for (int i = size - 2; i >= 0; i--) {
            width[i] = width[i * 2 + 1] + width[i * 2 + 2];
        }
    }
    void lazy_propagate(int p) {
        data[p] = updater(data[p], lazy[p], width[p]);
        if (p < size-1) {
            lazy[p * 2 + 1] = propagater(lazy[p * 2 + 1], lazy[p]);
            lazy[p * 2 + 2] = propagater(lazy[p * 2 + 2], lazy[p]);
        }
        lazy[p] = ident_prop;
    }
    void update(int wishL, int wishR, int x, int watchL = 0, int watchR = -1, int k = 0) {
        if (watchR == -1) watchR = size;
        if (wishR <= watchL || watchR <= wishL) {
            lazy_propagate(k);
            return;
        }
        if (wishL <= watchL && watchR <= wishR) {
            lazy[k] = propagater(lazy[k], x);
            lazy_propagate(k);
            return;
        }

        int mid = (watchL + watchR) / 2;
        lazy_propagate(k);
        update(wishL, wishR, x, watchL, mid, k * 2 + 1);
        update(wishL, wishR, x, mid, watchR, k * 2 + 2);
        data[k] = merger(data[k * 2 + 1], data[k * 2 + 2]);
    }
    T query(int wishL, int wishR, int watchL = 0, int watchR = -1, int k = 0) {
        if (watchR == -1) watchR = size;
        if (watchR <= wishL || wishR <= watchL) return ident_query;
        if (wishL <= watchL && watchR <= wishR) {
            lazy_propagate(k);
            return data[k];
        }
        lazy_propagate(k);
        T ld = query(wishL, wishR, watchL, (watchL + watchR) / 2, k * 2 + 1);
        T rd = query(wishL, wishR, (watchL + watchR) / 2, watchR, k * 2 + 2);
        return merger(ld, rd);
    }
};

/// Range Add - Range Sum
/*
auto update = [](int a, int b, int w) {return a + b * w;};
auto merge = [](int a, int b) {return a + b;};
auto propagate = [](int a, int b) {return a + b;};
LazySegmentTree<int> radd_rsum(n, update, merge, propagate, 0, 0);
*/

/// Starry Sky Tree
/*
auto update = [](int a, int b, int w) {return a + b;};
auto merge = [](int a, int b) {return min(a, b);};
auto propagate = [](int a, int b) {return a + b;};
LazySegmentTree<int> seg(N, update, merge, propagate, 0, INF);
seg.update(0, N, -INF);
*/
