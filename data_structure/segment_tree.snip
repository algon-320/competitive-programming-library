/*
<NAME> SegmentTree
<TRIGGER> SegmentTree
<TAG> data-structure
<*NOTE>
更新$O(log N)$、クエリ$O(log N)$。
<*CODE> */
template<typename Monoid>
struct SegmentTree {
    using T = typename Monoid::T;
    size_t n;
    vector<T> t;

    void prop_to(std::size_t i) { t[i] = Monoid::op(t[i << 1], t[i << 1 | 1]); }
    SegmentTree(size_t size, const T& v = Monoid::identity()) {
        n = 1;
        while (n < size) n <<= 1;
        t.resize(n << 1, v);
    }
    template <class InputIt>
    SegmentTree(InputIt first, InputIt last) : n(distance(first, last)), t(n << 1, Monoid::identity()) {
        copy(first, last, begin(t) + n);
        for (size_t i = n - 1; i > 0; i--) prop_to(i);
    }
    static T modify_update(const T& a, const T& b) { return b; }
    static T modify_add(const T& a, const T& b) { return a + b; }
    void update(size_t i, const T& v, const function<T(T, T)>& func = modify_update) {
        i += n;
        t[i] = func(t[i], v);
        while (i >>= 1) prop_to(i);
    }
    T query(size_t l, size_t r) {
        T res = Monoid::identity();
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if (l & 1) res = Monoid::op(res, t[l++]);
            if (r & 1) res = Monoid::op(res, t[--r]);
        }
        return res;
    }
    T get(size_t i) { return t[i + n]; }
};

struct RMQ {
    using T = int;
    static T op(T a, T b) { return min(a, b); }
    static constexpr T identity() { return (1LL << 31) - 1; }
};

struct RSQ {
    using T = int;
    static T op(T a, T b) { return a + b; }
    static constexpr T identity() { return 0; }
};
