<NAME> Treap
<TRIGGER> Treap
<TAG> data-structure, binary-search-tree
<*NOTE>
- 列として使うときはTrepArray、setとして使うときはTreapOrderedSet
<*CODE>
template <typename T, T ZERO>
class Treap {
public:
    struct Node {
        T val;
        T data;
        bool cached;
        Node *left, *right;
        int priority;
        size_t size;
        Node(T val) : val(val), data(val), cached(true), size(1) {
            priority = rand();
            left = right = nullptr;
        }
        ~Node() { delete left; delete right; }
    };

    Node *root;
    Treap(Node *n) : root(n) {}

public:
    Treap() : root(nullptr) {}
    virtual ~Treap() { delete root; }

    const Node *get_root() { return root; }

    size_t size() { return size(root); }
    size_t size(Node *v) { return !v ? 0 : v->size; }

    Node *update(Node *v) {
        if (!v) return nullptr;
        v->size = size(v->left) + size(v->right) + 1;
        v->data = eval(v);
        return v;
    }

    T eval(Node *v) {
        if (!v) return ZERO;
        if (v->cached) return v->data;
        T l = ZERO, r = ZERO;
        if (v->left) l = eval(v->left);
        if (v->right) r = eval(v->right);
        v->data = min(v->val, min(l, r));
        v->cached = true;
        return v->data;
    }

    // [L, R)
    T query(size_t L, size_t R) {
        size_t len = R - L;
        Node *l, *m, *r;
        tie(l, r) = split(root, L);
        tie(m, r) = split(r, len);
        T ret = eval(m);
        r = merge(m, r);
        root = merge(l, r);
        return ret;
    }

    Node *merge(Node *l, Node *r) {
        if (!l or !r)
            return l ? l : r;
        if (l->priority > r->priority) {
            l->right = merge(l->right, r);
            l->cached = false;
            return update(l);
        } else {
            r->left = merge(l, r->left);
            r->cached = false;
            return update(r);
        }
    }
    // [0, k), [k, n)
    pair<Node*, Node*> split(Node *v, size_t k) {
        if (!v) return {nullptr, nullptr};
        size_t ls = size(v->left);
        if (k <= ls) {
            auto s = split(v->left, k);
            v->left = s.second;
            v->cached = false;
            return {s.first, update(v)};
        } else {
            auto s = split(v->right, k - ls - 1);
            v->right = s.first;
            v->cached = false;
            return {update(v), s.second};
        }
    }

    void insert(size_t k, T val) {
        root = insert(root, k, val);
    }
    Node *insert(Node *t, size_t k, T val) {
        auto s = split(t, k);
        t = merge(s.first, new Node(val));
        t = merge(t, s.second);
        return update(t);
    }

    void erase(size_t k) {
        root = erase(root, k);
    }
    Node *erase(Node *t, size_t k) {
        Node *l, *m, *r;
        tie(l, r) = split(t, k + 1);
        tie(l, m) = split(l, k);
        t = merge(l, r);
        delete m;
        return update(t);
    }

    T &find(size_t k) { 
        return find(root, k)->val;
    }
    Node *find(Node *t, size_t k) {
        size_t ls = size(t->left);
        if (ls == k) return t;
        if (k < ls) return find(t->left, k);
        return find(t->right, k - ls - 1);
    }
};

template <typename T, T ZERO>
class TreapArray : public Treap<T, ZERO> {
    using Node = typename Treap<T, ZERO>::Node;
public:
    void change(size_t p, T value) {
        this->erase(p);
        this->insert(p, value);
    }
    void push_back(T value) { this->insert(this->size(this->root), value); }
    void push_front(T value) { this->insert(0, value); }
    void pop_back() { this->erase(this->size(this->root) - 1); }
    void pop_front() { this->erase(0); }
    T &back() { return this->find(this->size(this->root) - 1); }
    T &front() { return this->find(0); }
};

template <typename T, T ZERO>
class TreapOrderedSet : public Treap<T, ZERO> {
    using Node = typename Treap<T, ZERO>::Node;
public:
    TreapOrderedSet() : Treap<T, ZERO>() {}
    TreapOrderedSet(Node *n) : Treap<T, ZERO>(n) {}
    
    pair<TreapOrderedSet, TreapOrderedSet> split_less(const T &x) {
        auto p = __split(this->root, x, false);
        return {TreapOrderedSet(p.first), TreapOrderedSet(p.second)};
    }
    pair<TreapOrderedSet, TreapOrderedSet> split_leq(const T &x) {
        auto p = __split(this->root, x, true);
        return {TreapOrderedSet(p.first), TreapOrderedSet(p.second)};
    }
    pair<Node*, Node*> __split(Node *n, const T &x, bool leq) {
        if (n == nullptr) return {nullptr, nullptr};
        if (n->val < x || (leq && n->val == x)) {
            auto p = __split(n->right, x, leq);
            n->right = p.first;
            return {this->update(n), p.second};
        } else {
            auto p = __split(n->left, x, leq);
            n->left = p.second;
            return {p.first, this->update(n)};
        }
    }

    void insert(const T &x) { this->root = __insert(this->root, x); }
    Node *__insert(Node *n, const T &x) {
        auto p = __split(n, x, false);
        return this->merge(this->merge(p.first, new Node(x)), p.second);
    }

    void erase_one(const T &x) {
        assert(contains(this->root, x));
        this->root = __erase_one(this->root, x);
    }
    Node *__erase_one(Node *n, const T &x) {
        Node *l, *m, *r;
        tie(l, r) = __split(n, x, false);
        tie(m, r) = this->split(r, 1);
        return this->merge(l, r);
    }

    void erase_all(const T &x) { this->root = __erase_all(this->root, x); }
    Node *__erase_all(Node *n, const T &x) {
        Node *l, *m, *r;
        tie(l, r) = __split(n, x, false);
        tie(m, r) = __split(r, x, true);
        return this->merge(l, r);
    }

    size_t count_less(const T &x) { return __count(this->root, x, false); }
    size_t count_leq(const T &x) { return __count(this->root, x, true); }
    size_t __count(const Node *n, const T &x, bool leq) {
        if (n == nullptr) return 0;
        if (n->val < x || (leq && n->val == x)) {
            return this->size(n->left) + 1 + __count(n->right, x, leq);
        } else {
            return __count(n->left, x, leq);
        }
    }
    size_t count(const T &x) { return count_leq(x) - count_less(x); }

    bool contains(const T &x) { return __contains(this->root, x); }
    bool __contains(const Node *n, const T &x) {
        if (n == nullptr) return false;
        if (n->val < x) {
            return __contains(n->right, x);
        } else if (n->val == x) {
            return true;
        } else {
            return __contains(n->left, x);
        }
    }

    T lower_bound(const T &x) { return __lower_bound(this->root, x)->val; }
    Node *__lower_bound(Node *n, const T &x) {
        if (n == nullptr) return nullptr;
        if (n->val < x) {
            return __lower_bound(n->right, x);
        } else {
            Node *res = __lower_bound(n->left, x);
            return res ? res : n;
        }
    }

    T upper_bound(const T &x) { return __upper_bound(this->root, x)->val; }
    Node *__upper_bound(Node *n, const T &x) {
        if (n == nullptr) return nullptr;
        if (n->val <= x) {
            return __upper_bound(n->right, x);
        } else {
            Node *res = __upper_bound(n->left, x);
            return res ? res : n;
        }
    }
};