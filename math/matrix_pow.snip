/*
<NAME> 行列累乗
<TRIGGER>
<TAG> math
<*NOTE>
半環ならば行列累乗可能

<*CODE> */
template<typename T>
void resize_matrix(vector<vector<T>> &A, int h, int w, T fill) {
    A.resize(h);
    for (int i = 0; i < h; i++) {
        A[i].resize(w, fill);
    }
}
template<typename T>
vector<vector<T>> multiple_matrix(vector<vector<T>> &A, vector<vector<T>> &B,
  function<T(T, T)> add = [](T a, T b){return a + b;},
  function<T(T, T)> mul = [](T a, T b){return a * b;},
  T zero = 0) {
    int m = A.size();
    int n = A[0].size();
    assert(n == B.size());
    int l = B[0].size();
    vector<vector<T>> res;
    resize_matrix(res, m, l, zero);
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < l; j++) {
            T tmp = zero;
            for (int k = 0; k < n; k++) {
                T p = mul(A[i][k], B[k][j]);
                tmp = add(tmp, p);
            }
            res[i][j] = tmp;
        }
    }
    return res;
}
template <typename T>
vector<vector<T>> pow_matrix(vector<vector<T>> A, int k,
  function<T(T, T)> add = [](T a, T b){return a + b;},
  function<T(T, T)> mul = [](T a, T b){return a * b;},
  T e = 1, T zero = 0) {
    int n = A.size();
    assert(n == A[0].size());

    vector<vector<T>> res;
    resize_matrix(res, n, n, zero);
    for (int i = 0; i < n; i++) res[i][i] = e;
    while (k > 0) {
        if (k & 1) res = multiple_matrix(res, A, add, mul, zero);
        A = multiple_matrix(A, A, add, mul, zero);
        k >>= 1;
    }
    return res;
}
